# 動的セグメント木

```admonish warning
この節は書きかけです。
```

動的セグメント木は必要なノードだけを作成することで、巨大（$N \gg 10^5$）な配列でもセグメント木を構築できるようにしたものです。

## 実装方針

高速化のために以下の方針を採用します：

- ポインターではなくアリーナ[^arena]で木をつくる
- 非再帰実装

また、簡単のために、追加の制約を課します：

- `Range<isize>`で初期化し、区間幅は固定
- 単位元で初期化

~~~admonish example title="実装例（動的セグメント木）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:definition }}
```

`Node<T>`の詳細は後述します。

非可換モノイドでは要素の合成順が重要です。
後述のように、正しい順序で要素を合成するためにスタックを使用します。
`reusable_stack`はスタックの長さが$\lceil \log N \rceil$で抑えられることを利用して、アロケーションコストを節約するためにあります。
~~~

## 計算量

区間幅を$N$とし、ある時点での更新クエリの数を$Q$とします。

|                       | arena        | range query | point update |
| --------------------- | ------------ | ----------- | ------------ |
| time/space complexity | $\Theta (Q)$ | $O(\log N)$ | $O(\log N)$  |

## 実装例

### 初期化子

`seg_lib`において動的セグメント木の区間は初期値で固定されます。
`Range`型は不正な区間（`1..0`など）を持つことができるため、これをケアする必要があります。
区間幅がゼロの場合もまとめて`range.is_empty()`で処理できます。

~~~admonish example title="実装例（初期化子）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:with_capacity }}
```
`seg_lib`は[crates.io](https://crates.io/crates/seg_lib)で公開しているため、返り値に`Option`型を取ることにしました。
競プロなどでは`panic!()`するのもありです。
~~~

~~~admonish tip
単位元以外の値で初期化することもできます。

可換モノイドの場合は簡単で、以下のようにしてモノイドに更新済みノード数を持たせるだけです。
初期値をもつノードの数は`区間幅 - 更新済みノード数`で与えられるので、繰り返し自乗法などをもちいて$O(\log N)$で計算できます。
```rust, no_run
use seg_lib::{DynamicSegmentTree, ops::Add};

let mut dst = DynamicSegmentTree::<(/* operation */, Add<usize>)>::new(/* range */);
dst.point_update(/* index */, (/* value */, 1));
let (combined, n) = dst.range_query(/* sub range */);
```

非可換モノイドを扱う場合、計算順序を守るために、実装に踏み入る必要があります。
ノードごとに$O(\log N)$かかるので、取得クエリ・更新クエリの計算量が$O(\log^2 N)$に悪化します。
または、動的遅延伝搬セグメント木を利用してもよいです。
~~~

### ノード

動的セグメント木では必要最小限のノードを作成することで、空間計算量$\Theta(Q)$を実現します。

通常のセグメント木のように、各ノードに対応する区間の途中結果をもつ場合、空間計算量が$O(Q \log N)$になってしまいます。
対応する区間に更新されたノードが1つしかない場合にノードの作成を遅延することで、空間計算量を$O(Q)$に削減できます。

~~~admonish example title="実装例（初期化子）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:node }}
```
- `seg_lib`の動的セグメント木では区間幅を固定しているので、各ノードが持つ区間情報は暗黙的に与えられます。
区間情報は根から子を辿る際に計算できるので、ノードには持ちません。
- ノードに対応する区間の途中結果には`Option`型を採用しました。
これはトレイト境界`<Query as Monoid>::Set: Clone`を回避するためです。
- 通常`Option`型は追加のフラグに8byte（64bitシステムの場合）利用しますが、`Option<NonZero<T>>`では`0`を`None`と扱う最適化が施されており、追加のメモリは必要ありません。
`arena`の0要素目は根なので、子のインデックスは常に正です。
~~~

### 更新クエリ

あるノードに対応する区間で2つめのノードが更新される場合、新たにノードを作成する必要があります。
このとき、`左の子のインデックス < 親のインデックス < 右の子のインデックス`の関係を保持する必要があります。
また、途中結果を帰りがけ順序で再計算する必要があります。
ここでも、`reusable_stack`を活用してアロケーションコストを節約します。

~~~admonish example title="実装例（一点更新）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:point_update }}
```
~~~

### 取得クエリ

動的セグメント木においてもっとも複雑な部分です。
アルゴリズムの概略は以下の通りです。

1. 所望の区間が1つのノードに完全に含まれる限り子ノードを探索する。
このとき、作成を遅延しているノードが区間に含まれる場合、`reusable_stack`に追加し、値の合成は遅延する。
2. 所望の区間が2つのノードにまたがる場合、左右の子を探索し、途中結果を合成していく。
3. `reusable_stack`のノードを帰りがけに合成していく。

値の合成が2段階に分けられています。
これは値の合成順序を守るために必要な措置です。

<!-- 図示する -->

[^arena]: 配列上にノードを格納し、インデックスをポインター代わりにするテクニックのこと。キャッシュ効率が良く、所有権の管理が容易。
