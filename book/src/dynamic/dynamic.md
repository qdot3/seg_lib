# 動的セグメント木

動的セグメント木は必要なノードだけを作成することで、巨大（$N \gg 10^5$）な配列でもセグメント木を構築できるようにしたものです。

## 実装方針

高速化のために以下の方針を採用します：

- ポインターではなくアリーナ[^arena]で木をつくる
- 非再帰実装

また、簡単のために、追加の制約を課します：

- `Range<isize>`で初期化し、区間幅は固定
- 単位元で初期化

~~~admonish example title="実装例（動的セグメント木）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:definition }}
```

`Node<T>`の詳細は後述します。

非可換モノイドでは要素の合成順が重要です。
後述のように、正しい順序で要素を合成するためにスタックを使用します。
`reusable_stack`はスタックの長さが$\lceil \log N \rceil$で抑えられることを利用して、アロケーションコストを節約するためにあります。
~~~

## 計算量

区間幅を$N$とし、ある時点での更新クエリの数を$Q$とします。

|                       | arena        | range query | point update |
| --------------------- | ------------ | ----------- | ------------ |
| time/space complexity | $\Theta (Q)$ | $O(\log N)$ | $O(\log N)$  |

## 実装例

### 初期化子

`seg_lib`において動的セグメント木の区間は初期値で固定されます。
`Range`型は不正な区間（`1..0`など）を持つことができるため、これをケアする必要があります。
区間幅がゼロの場合もまとめて`range.is_empty()`で処理できます。

~~~admonish example title="実装例（初期化子）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:with_capacity }}
```
`seg_lib`は[crates.io](https://crates.io/crates/seg_lib)で公開しているため、返り値に`Option`型を取ることにしました。
競プロなどでは`panic!()`するのもありです。
~~~

~~~admonish tip
単位元以外の値で初期化することもできます。

可換モノイドの場合は簡単で、以下のようにしてモノイドに更新済みノード数を持たせるだけです。
初期値をもつノードの数は`区間幅 - 更新済みノード数`で与えられるので、繰り返し自乗法などをもちいて$O(\log N)$で計算できます。
```rust, no_run
use seg_lib::{DynamicSegmentTree, ops::Add};

let mut dst = DynamicSegmentTree::<(/* operation */, Add<usize>)>::new(/* range */);
dst.point_update(/* index */, (/* value */, 1));
let (combined, n) = dst.range_query(/* sub range */);
```

非可換モノイドを扱う場合、計算順序を守るために、実装に踏み入る必要があります。
ノードごとに$O(\log N)$かかるので、取得クエリ・更新クエリの計算量が$O(\log^2 N)$に悪化します。
または、動的遅延伝搬セグメント木を利用してもよいです。
~~~

### ノード

動的セグメント木では必要最小限のノードを作成することで、空間計算量$\Theta(Q)$を実現します。

通常のセグメント木のように、各ノードに対応する区間の途中結果をもつ場合、空間計算量が$O(Q \log N)$になってしまいます。
対応する区間に更新されたノードが1つしかない場合にノードの作成を遅延することで、空間計算量を$\Theta(Q)$に削減できます。

~~~admonish example title="実装例（初期化子）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:node }}
```
- `seg_lib`の動的セグメント木では区間幅を固定しているので、各ノードが持つ区間情報は暗黙的に与えられます。
区間情報は根から子を辿る際に計算できるので、ノードには持ちません。
- ノードに対応する区間の途中結果には`Option`型を採用しました。
これはトレイト境界`<Query as Monoid>::Set: Clone`を回避するためです。
- 通常`Option`型は追加のフラグに8byte（64bitシステムの場合）利用しますが、`Option<NonZero<T>>`では`0`を`None`と扱う最適化が施されており、追加のメモリは必要ありません。
`arena`の0要素目は根なので、子のインデックスは常に正です。
~~~

### 更新クエリ

![range update](dynamic_pu.drawio.svg)

あるノードに対応する区間で2つめのノードが更新される場合、新たにノードを作成する必要があります。
このとき、`左の子のインデックス < 親のインデックス < 右の子のインデックス`の関係を保持する必要があります。
また、途中結果を帰りがけ順序で再計算する必要があります。
ここで、`reusable_stack`を活用してアロケーションコストを節約します。

### 取得クエリ

動的セグメント木においてもっとも複雑な部分です。

#### 観察

区間クエリが1つのノードに収まる場合と、2つのノードにまたがる場合で場合分けができます。

![range query](dynamic_rq.drawio.svg)

タイプ1の場合、次に訪問するノードが右（左）の子ならば、合成順序は最後のノードよりも左（右）側です。
また、訪問順序が早いノードほど外側にあることが分かります。
`reusable_stack`を活用することで、この順序を再現できます。

タイプ2の場合に左の子を祖先に持つノード群を合成することを考えます。
`L1`から始めて、次に外側の`L3`に進むので、内側にある`L2`は答えに含まれます。
`L1`自身の持つノードは外側から合成します。
`L3`の次は内側のノードである`L4`に進みます。
`L4`の配下は明示されていないので何とも言えませんが、`L3`のノードを合成する場合は一番外側からであることは保証されます。
したがって、`L3`の持つノードへのポインター[^arena_pointer]を`reusable_stack`に格納します。

右側の子孫たちの合成順序で確認してみてください。
`R1`の次は内側に進むので、`reusable_stack`に格納します。
`R2`の次は外側に進むので、`R3`を右から合成し、`R2`を右から合成します。

#### `reusable_stack`における左右の区別

ここまでで、`reusable_stack`には0個以上のポインターが格納されています。
ポインターはただの`usize`なので、左右の区別をするために工夫をする必要があります。

ポインターはアリーナのインデックスであり、アリーナは`Vec`です。
実は、`Vec`の容量の最大値は`isize::MAX`と決まっています。
たとえば、[`Vec::with_capacity()`で`isize::MAX`より大きな容量を与えると`panic`します](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity)。
したがって、`usize`の最上位ビットをフラグとして利用できます。

~~~admonish example title="実装例（左右の区別）"
```rust, no_run
{{ #include ../../../src/dynamic.rs:reusable_stack }}
```

`res`はタイプ2の場合の内側の計算結果です。

左側のノードへのポインターはそのまま、右側のノードへのポインターはビット反転してから、`reusable_stack`に格納しています。
~~~

[^arena]: 配列上にノードを格納し、インデックスをポインター代わりにするテクニックのこと。キャッシュ効率が良く、所有権の管理が容易。
[^arena_pointer]: ノードのインデックスと区別するために、アリーナ上のインデックスをポインターと呼ぶことにします。
