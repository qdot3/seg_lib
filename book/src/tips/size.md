# サイズ

セグメント木のサイズは、要素数を$N$として$2^{\lceil \log_2 N \rceil + 1}$とかけます。
末尾の余分な要素を除去して、`n.next_power_of_two() + n + (n & 1)`とすることもできます。サイズを偶数にしておくと実装が楽です。

さらに、サイズを$2N$にすることもできます。
メモリの使用量が少なく、とくに$N = 2^n + 1$のとき、使用するメモリの比はおよそ$4:3:2$です。
しかしながら、いくつかのアルゴリズムの実装が複雑になります。

![segment tree](size.drawio.svg)

$N$の立っているビットごとに完全二分木を作ることもできます。
高々$\log N$個の木を管理する必要があるため、サイズは$2N + O(\log N)$です。
追加のメモリコストを支払う代わりに不正なセグメントができないため、実装がシンプルになる可能性があります。
添え字を木と対応づけるためには`usize::MAX - (N - i).leading_zeros()`などとすればよいです[^panic-less]。
ただし、サイズ$2^k$の木が配列の`k`要素目に格納されています。

## 特別な場合

$N = 0, 2^n$のとき、ビット演算をうまく使った実装が壊れることがあります。
たとえば、`i >>= i.trailing_zeros()`などです。
小さな$N$について、網羅的に単体テストをすると、この種のバグを発見できます。

~~~admonish example title="単体テスト"
区間和クエリを確かめる場合、$1$で初期化してておくと、セグメントの和とサイズが一致する。
```rust
{{ #include ../../../src/normal.rs:test }}
```
~~~

[^panic-less]: 区間クエリの終端が`N`でないことが分かっている場合、`(N - i).ilog2()`とできます。
